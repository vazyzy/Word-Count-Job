/**
 * Generated by Scrooge
 *   version: 3.16.3
 *   rev: b8593c83072d94fc44feaa8d97940b9266d84ed0
 *   built at: 20140806-054445
 */
package ru.livetex.wordcount.thrift

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}

/**
 * Сервис слов.
 *
 * @version 0.0.1
 */
@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait WordsEventService[+MM[_]] extends ThriftService {
  
  def sendWordEvent(wordsEvent: WordsEvent): MM[Unit]
}

/**
 * Сервис слов.
 *
 * @version 0.0.1
 */
object WordsEventService {
  
  object sendWordEvent$args extends ThriftStructCodec3[sendWordEvent$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendWordEvent_args")
    val WordsEventField = new TField("wordsEvent", TType.STRUCT, 1)
    val WordsEventFieldManifest = implicitly[Manifest[WordsEvent]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        WordsEventField,
        false,
        WordsEventFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendWordEvent$args) {
    }
  
    override def encode(_item: sendWordEvent$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendWordEvent$args = {
      var wordsEvent: WordsEvent = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  wordsEvent = readWordsEventValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'wordsEvent' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendWordEvent$args(
        wordsEvent,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      wordsEvent: WordsEvent
    ): sendWordEvent$args =
      new sendWordEvent$args(
        wordsEvent
      )
  
    def unapply(_item: sendWordEvent$args): Option[WordsEvent] = Some(_item.wordsEvent)
  
  
    private def readWordsEventValue(_iprot: TProtocol): WordsEvent = {
      WordsEvent.decode(_iprot)
    }
  
    private def writeWordsEventField(wordsEvent_item: WordsEvent, _oprot: TProtocol) {
      _oprot.writeFieldBegin(WordsEventField)
      writeWordsEventValue(wordsEvent_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeWordsEventValue(wordsEvent_item: WordsEvent, _oprot: TProtocol) {
      wordsEvent_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendWordEvent$args(
      val wordsEvent: WordsEvent,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[WordsEvent]
    with java.io.Serializable
  {
    import sendWordEvent$args._
      def this(
        wordsEvent: WordsEvent
      ) = this(
        wordsEvent,
        Map.empty
      )
  
    def _1 = wordsEvent
  
  
    override def write(_oprot: TProtocol) {
      sendWordEvent$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (wordsEvent ne null) writeWordsEventField(wordsEvent, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      wordsEvent: WordsEvent = this.wordsEvent,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendWordEvent$args =
      new sendWordEvent$args(
        wordsEvent,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendWordEvent$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendWordEvent$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.wordsEvent
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendWordEvent$args"
  }
  
  object sendWordEvent$result extends ThriftStructCodec3[sendWordEvent$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendWordEvent_result")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendWordEvent$result) {
    }
  
    override def encode(_item: sendWordEvent$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendWordEvent$result = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendWordEvent$result(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): sendWordEvent$result =
      new sendWordEvent$result(
      )
  
    def unapply(_item: sendWordEvent$result): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendWordEvent$result(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import sendWordEvent$result._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      sendWordEvent$result.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendWordEvent$result =
      new sendWordEvent$result(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendWordEvent$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendWordEvent$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendWordEvent$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  WordsEventService[Future] {
    
    def sendWordEvent(wordsEvent: WordsEvent): Future[Unit]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends WordsEventService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends WordsEventService$FinagleService(
      iface,
      protocolFactory)
}